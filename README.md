# Gozon Store

Микросервисное приложение интернет-магазина с API Gateway и фронтендом

Комиссарова Юлия БПИ249

Конструирование программного обеспечения
Домашнее задание №4

---

## Сборка проекта

### Требования

* Docker (версия 20 и выше)
* Docker Compose
* Свободные порты:

    * 8080 API Gateway
    * 8081 Orders Service (Swagger)
    * 8082 Payments Service (Swagger)
    * 8083 Frontend (Web UI)
    * 5672 RabbitMQ
    * 15672 RabbitMQ Management UI

---

## Инструкция по запуску

1. Клонировать репозиторий и перейти в папку проекта:

```
git clone <repository-url>
cd Gogon_Store
```

2. Запустить все сервисы одной командой:

```
docker compose up --build
```

3. Дождаться, пока все контейнеры перейдут в состояние `running`.

---

## Доступные сервисы после запуска

### Frontend (веб-интерфейс)

Минимальный пользовательский интерфейс для работы с системой:

[http://localhost:8083/index.html](http://localhost:8083/index.html)

### API Gateway

Единая точка входа для всех клиентских запросов:

[http://localhost:8080](http://localhost:8080)

### Orders Service

Swagger UI сервиса заказов:

[http://localhost:8081/swagger](http://localhost:8081/swagger)

### Payments Service

Swagger UI сервиса аккаунтов и баланса:

[http://localhost:8082/swagger](http://localhost:8082/swagger)

### RabbitMQ

Web-интерфейс брокера сообщений:

[http://localhost:15672](http://localhost:15672)
(login: guest, password: guest)

---

## 1. Общая идея решения

Проект представляет собой микросервисную систему интернет-магазина. Пользователь работает с системой через простой веб-интерфейс. Все запросы с фронтенда отправляются в API Gateway, который маршрутизирует их в соответствующие микросервисы.

Основная функциональность:

* работа с аккаунтом пользователя по логину
* пополнение баланса
* создание заказов
* просмотр списка заказов пользователя

---

## 2. Архитектура проекта

Архитектура построена по микросервисному подходу и включает следующие компоненты:

### Payments Service

Отвечает за:

* создание аккаунта пользователя по логину
* хранение баланса
* пополнение баланса

Использует:

* ASP.NET Core
* SQLite
* RabbitMQ (для обработки событий оплаты)

### Orders Service

Отвечает за:

* создание заказов
* хранение заказов
* получение списка заказов по логину пользователя

Использует:

* ASP.NET Core
* SQLite
* RabbitMQ (для запроса списания средств и получения результата)

### API Gateway (YARP Reverse Proxy)

Отвечает только за маршрутизацию запросов:

* `/accounts/**` -> Payments Service
* `/orders/**` -> Orders Service

Gateway не содержит бизнес-логики и является тонким маршрутизатором.

### Frontend

Минимальное веб-приложение:

* одна HTML-страница
* взаимодействие с системой через REST API
* все запросы идут через API Gateway

---

## 3. Пользовательские сценарии

### 3.1 Выбор пользователя

Пользователь вводит логин в поле ввода.
Этот логин используется для всех последующих операций и отображается на странице.

Если аккаунта с таким логином ещё нет, он создаётся автоматически при первом запросе.

---

### 3.2 Работа с аккаунтом (Payments Service)

#### Создание аккаунта

* Происходит автоматически при первом обращении по логину
* Явного шага регистрации нет

#### Пополнение баланса

* Пользователь вводит сумму
* Отправляется запрос:

```
POST /accounts/topup-by-login
```

* Баланс обновляется и сразу отображается в интерфейсе

---

### 3.3 Работа с заказами (Orders Service)

#### Создание заказа

* Пользователь вводит сумму и описание заказа
* Отправляется запрос:

```
POST /orders
```

* Orders Service отправляет запрос на списание средств через RabbitMQ
* После получения результата заказ получает статус (Paid или Rejected)

#### Просмотр заказов

* Пользователь может запросить список всех своих заказов:

```
GET /orders?login=...
```

* Заказы отображаются в таблице на странице

---

## 4. Техническое взаимодействие сервисов

### Асинхронное взаимодействие

* Orders Service и Payments Service обмениваются сообщениями через RabbitMQ
* Используется паттерн Outbox
* Списания средств происходят асинхронно

### Хранение данных

* Каждый микросервис использует свою SQLite базу данных
* Базы вынесены в Docker volumes, данные не теряются при перезапуске

---

## 5. Реализация требований задания

### Микросервисная архитектура

* Реализованы два независимых микросервиса (Orders и Payments)
* Каждый сервис имеет собственную БД и область ответственности

### API Gateway

* Реализован отдельный сервис Gateway
* Используется YARP Reverse Proxy
* Gateway выполняет только маршрутизацию запросов

### Асинхронное взаимодействие

* Используется RabbitMQ
* Реализован обмен событиями между сервисами заказов и платежей

### Frontend

* Реализован как отдельный сервис
* Взаимодействует с backend только через API Gateway
* Представляет минимальный, но рабочий интерфейс
* Упакован в Docker-контейнер
* Запускается через Docker Compose вместе с остальными сервисами

### Контейнеризация

* Каждый сервис имеет свой Dockerfile
* Вся система поднимается одной командой docker compose up
* Используются Docker volumes для хранения данных

